size <- (scale[1] - scale[2]) * normedFreq + scale[2]
boxes <- list()
for (i in 1:length(words)) {
rotWord <- runif(1) < rot.per
r <- 0
theta <- runif(1, 0, 2 * pi)
x1 <- 0.5
y1 <- 0.5
wid <- strwidth(words[i], cex = size[i], ...)
ht <- strheight(words[i], cex = size[i], ...)
if (grepl(tails, words[i]))
ht <- ht + ht * 0.2
if (rotWord) {
tmp <- ht
ht <- wid
wid <- tmp
}
isOverlaped <- TRUE
while (isOverlaped) {
if (!overlap(x1 - 0.5 * wid, y1 - 0.5 * ht, wid,
ht) && x1 - 0.5 * wid > 0 && y1 - 0.5 * ht >
0 && x1 + 0.5 * wid < 1 && y1 + 0.5 * ht < 1) {
if (!random.color) {
if (ordered.colors) {
cc <- colors[i]
}
else {
cc <- ceiling(nc * normedFreq[i])
cc <- colors[cc]
}
}
else {
cc <- colors[sample(1:nc, 1)]
}
text(x1, y1, words[i], cex = size[i], offset = 0,
srt = rotWord * 90, col = cc, ...)
boxes[[length(boxes) + 1]] <- c(x1 - 0.5 * wid,
y1 - 0.5 * ht, wid, ht)
isOverlaped <- FALSE
}
else {
if (r > sqrt(0.5)) {
warning(paste(words[i], "could not be fit on page. It will not be plotted."))
isOverlaped <- FALSE
}
theta <- theta + thetaStep
r <- r + rStep * thetaStep/(2 * pi)
x1 <- 0.5 + r * cos(theta)
y1 <- 0.5 + r * sin(theta)
}
}
}
par(mar = op)
invisible()
}
wordcloud2<-function (words, freq, scale = c(4, 0.5), min.freq = 3, max.words = Inf,
random.order = TRUE, random.color = FALSE, rot.per = 0.1,
colors = "black", ordered.colors = FALSE, use.r.layout = FALSE,
fixed.asp = TRUE, ...)
{
if (!fixed.asp && rot.per > 0)
stop("Variable aspect ratio not supported for rotated words. Set rot.per=0.")
tails <- "g|j|p|q|y"
last <- 1
nc <- length(colors)
if (missing(freq)) {
if (!require("tm"))
stop("freq must either be non-missing, or the tm package must be available")
if (is.character(words) || is.factor(words)) {
corpus <- Corpus(VectorSource(words))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, function(x) removeWords(x,
stopwords()))
}
else corpus <- words
tdm <- TermDocumentMatrix(corpus)
freq <- slam::row_sums(tdm)
words <- names(freq)
}
if (ordered.colors) {
if (length(colors) != 1 && length(colors) != length(words)) {
stop(paste("Length of colors does not match length of words",
"vector"))
}
}
if (min.freq > max(freq))
min.freq <- 0
overlap <- function(x1, y1, sw1, sh1) {
if (!use.r.layout)
return(.overlap(x1, y1, sw1, sh1, boxes))
s <- 0
if (length(boxes) == 0)
return(FALSE)
for (i in c(last, 1:length(boxes))) {
bnds <- boxes[[i]]
x2 <- bnds[1]
y2 <- bnds[2]
sw2 <- bnds[3]
sh2 <- bnds[4]
if (x1 < x2)
overlap <- x1 + sw1 > x2 - s
else overlap <- x2 + sw2 > x1 - s
if (y1 < y2)
overlap <- overlap && (y1 + sh1 > y2 - s)
else overlap <- overlap && (y2 + sh2 > y1 - s)
if (overlap) {
last <<- i
return(TRUE)
}
}
FALSE
}
ord <- rank(-freq, ties.method = "random")
words <- words[ord <= max.words]
freq <- freq[ord <= max.words]
if (ordered.colors) {
colors <- colors[ord <= max.words]
}
if (random.order)
ord <- sample.int(length(words))
else ord <- order(freq, decreasing = TRUE)
words <- words[ord]
freq <- freq[ord]
words <- words[freq >= min.freq]
freq <- freq[freq >= min.freq]
if (ordered.colors) {
colors <- colors[ord][freq >= min.freq]
}
thetaStep <- 0.1
rStep <- 0.05
plot.new()
op <- par("mar")
par(mar = c(0, 0, 0, 0))
if (fixed.asp)
plot.window(c(0, 1), c(0, 1), asp = 1)
else plot.window(c(0, 1), c(0, 1))
normedFreq <- freq/max(freq)
size <- (scale[1] - scale[2]) * normedFreq + scale[2]
boxes <- list()
for (i in 1:length(words)) {
rotWord <- runif(1) < rot.per
r <- 0
theta <- runif(1, 0, 2 * pi)
x1 <- 0.5
y1 <- 0.5
wid <- strwidth(words[i], cex = size[i], ...)
ht <- strheight(words[i], cex = size[i], ...)
if (grepl(tails, words[i]))
ht <- ht + ht * 0.2
if (rotWord) {
tmp <- ht
ht <- wid
wid <- tmp
}
isOverlaped <- TRUE
while (isOverlaped) {
if (!overlap(x1 - 0.5 * wid, y1 - 0.5 * ht, wid,
ht) && x1 - 0.5 * wid > 0 && y1 - 0.5 * ht >
0 && x1 + 0.5 * wid < 1 && y1 + 0.5 * ht < 1) {
if (!random.color) {
if (ordered.colors) {
cc <- colors[i]
}
else {
cc <- ceiling(nc * normedFreq[i])
cc <- colors[cc]
}
}
else {
cc <- colors[sample(1:nc, 1)]
}
text(x1, y1, words[i], cex = size[i], offset = 0,
srt = rotWord * 90, col = cc, ...)
boxes[[length(boxes) + 1]] <- c(x1 - 0.5 * wid,
y1 - 0.5 * ht, wid, ht)
isOverlaped <- FALSE
}
else {
if (r > sqrt(0.5)) {
warning(paste(words[i], "could not be fit on page. It will not be plotted."))
isOverlaped <- FALSE
}
theta <- theta + thetaStep
r <- r + rStep * thetaStep/(2 * pi)
x1 <- 0.5 + r * cos(theta)
y1 <- 0.5 + r * sin(theta)
}
}
}
par(mar = op)
invisible()
}
wordcloud2<-function (words, freq, scale = c(4, 0.5), min.freq = 3, max.words = Inf,
random.order = TRUE, random.color = FALSE, rot.per = 0.1,
colors = "black", ordered.colors = FALSE, use.r.layout = FALSE,
fixed.asp = TRUE, ...)
{
if (!fixed.asp && rot.per > 0)
stop("Variable aspect ratio not supported for rotated words. Set rot.per=0.")
tails <- "g|j|p|q|y"
last <- 1
nc <- length(colors)
if (missing(freq)) {
if (!require("tm"))
stop("freq must either be non-missing, or the tm package must be available")
if (is.character(words) || is.factor(words)) {
corpus <- Corpus(VectorSource(words),readerControl = list(language="spanish"))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, function(x) removeWords(x,
stopwords()))
}
else corpus <- words
tdm <- TermDocumentMatrix(corpus)
freq <- slam::row_sums(tdm)
words <- names(freq)
}
if (ordered.colors) {
if (length(colors) != 1 && length(colors) != length(words)) {
stop(paste("Length of colors does not match length of words",
"vector"))
}
}
if (min.freq > max(freq))
min.freq <- 0
overlap <- function(x1, y1, sw1, sh1) {
if (!use.r.layout)
return(.overlap(x1, y1, sw1, sh1, boxes))
s <- 0
if (length(boxes) == 0)
return(FALSE)
for (i in c(last, 1:length(boxes))) {
bnds <- boxes[[i]]
x2 <- bnds[1]
y2 <- bnds[2]
sw2 <- bnds[3]
sh2 <- bnds[4]
if (x1 < x2)
overlap <- x1 + sw1 > x2 - s
else overlap <- x2 + sw2 > x1 - s
if (y1 < y2)
overlap <- overlap && (y1 + sh1 > y2 - s)
else overlap <- overlap && (y2 + sh2 > y1 - s)
if (overlap) {
last <<- i
return(TRUE)
}
}
FALSE
}
ord <- rank(-freq, ties.method = "random")
words <- words[ord <= max.words]
freq <- freq[ord <= max.words]
if (ordered.colors) {
colors <- colors[ord <= max.words]
}
if (random.order)
ord <- sample.int(length(words))
else ord <- order(freq, decreasing = TRUE)
words <- words[ord]
freq <- freq[ord]
words <- words[freq >= min.freq]
freq <- freq[freq >= min.freq]
if (ordered.colors) {
colors <- colors[ord][freq >= min.freq]
}
thetaStep <- 0.1
rStep <- 0.05
plot.new()
op <- par("mar")
par(mar = c(0, 0, 0, 0))
if (fixed.asp)
plot.window(c(0, 1), c(0, 1), asp = 1)
else plot.window(c(0, 1), c(0, 1))
normedFreq <- freq/max(freq)
size <- (scale[1] - scale[2]) * normedFreq + scale[2]
boxes <- list()
for (i in 1:length(words)) {
rotWord <- runif(1) < rot.per
r <- 0
theta <- runif(1, 0, 2 * pi)
x1 <- 0.5
y1 <- 0.5
wid <- strwidth(words[i], cex = size[i], ...)
ht <- strheight(words[i], cex = size[i], ...)
if (grepl(tails, words[i]))
ht <- ht + ht * 0.2
if (rotWord) {
tmp <- ht
ht <- wid
wid <- tmp
}
isOverlaped <- TRUE
while (isOverlaped) {
if (!overlap(x1 - 0.5 * wid, y1 - 0.5 * ht, wid,
ht) && x1 - 0.5 * wid > 0 && y1 - 0.5 * ht >
0 && x1 + 0.5 * wid < 1 && y1 + 0.5 * ht < 1) {
if (!random.color) {
if (ordered.colors) {
cc <- colors[i]
}
else {
cc <- ceiling(nc * normedFreq[i])
cc <- colors[cc]
}
}
else {
cc <- colors[sample(1:nc, 1)]
}
text(x1, y1, words[i], cex = size[i], offset = 0,
srt = rotWord * 90, col = cc, ...)
boxes[[length(boxes) + 1]] <- c(x1 - 0.5 * wid,
y1 - 0.5 * ht, wid, ht)
isOverlaped <- FALSE
}
else {
if (r > sqrt(0.5)) {
warning(paste(words[i], "could not be fit on page. It will not be plotted."))
isOverlaped <- FALSE
}
theta <- theta + thetaStep
r <- r + rStep * thetaStep/(2 * pi)
x1 <- 0.5 + r * cos(theta)
y1 <- 0.5 + r * sin(theta)
}
}
}
par(mar = op)
invisible()
}
wordcloud2(corpus_clean[["1"]][["content"]])
knitr::opts_chunk$set(echo = TRUE)
library(pdftools)
library(tm)
library(wordcloud)
library(stringi)
setwd("D:/ABCN/OneDrive/best/paquetes data bruta/varios/mensaje a la nacion")
my_pdf <- readPDF(control=list(text="-layout"))(elem=list(uri="MENSAJE.pdf"), language="es")
# my_pdf <- readPDF(control=list(text="-layout"))(elem=list(uri="MENSAJE.pdf"))
# my_pdf$meta
text_raw <- my_pdf$content
text_raw<-gsub("á", "a", text_raw)
text_raw<-gsub("é", "e", text_raw)
text_raw<-gsub("í", "i", text_raw)
text_raw<-gsub("ó", "o", text_raw)
text_raw<-gsub("ú", "u", text_raw)
text_raw<-gsub("Á", "A", text_raw)
text_raw<-gsub("É", "E", text_raw)
text_raw<-gsub("Í", "I", text_raw)
text_raw<-gsub("Ó", "O", text_raw)
text_raw<-gsub("Ú", "U", text_raw)
text_raw<-gsub("ñ", "n", text_raw)
text_raw<-gsub("Ñ", "N", text_raw)
text_raw<- text_raw[-c(1:2,37)]
# text_raw <- iconv(text_raw, "UTF-8", "latin1")
# scanner <- function(x) strsplit(x," ")
# text_corpus <- Corpus(VectorSource(text_raw),readerControl = list(language="spanish"))
text_corpus <- Corpus(DataframeSource(data.frame(text_raw)))
# Encoding(text_raw)
text_raw<- text_raw[-c(1:2,37)]
text_corpus <- Corpus(VectorSource(text_raw))
dtm <- TermDocumentMatrix(corpus_clean)
text_raw
text_raw<-gsub("MENSAJE A LA NACION – 28 de Julio de 2018", "", text_raw)
text_raw
my_stopwords <- c("ano","mas")
corpus_clean <- tm_map(corpus_clean, removeWords, my_stopwords)
install.packages("DT")
DT(d, 10)
library(DT)
DT::datatable(d, 10)
?datatable
text_raw<-gsub("Perus", "Peru", text_raw)
shiny::runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
strong
i
?strong
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
shiny::runApp('D:/ABCN/OneDrive/best/shinys/Terrorismo Global')
install.packages("blogdown")
usethis::edit_r_profile()
install.packages("usethis")
devtools::install_github("hadley/emo")
install.packages("rlang")
devtools::install_github("hadley/emo")
devtools::install_github("hadley/emo")
library(rlang)
install.packages("rlang")
library(rlang)
devtools::install_github("hadley/emo")
usethis::edit_r_profile()
setwd("~/best books/GitHub/DSFA")
setwd("~/best books/GitHub/DSFA")
bookdown::publish_book("index.Rmd")
bookdown::render_book()
bookdown::render_book("index.Rmd")
bookdown::publish_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::publish_book("index.Rmd")
bookdown::publish_book("index.Rmd")
library(bookdown)
=publish_book
?publish_book
bookdown::publish_book("index.Rmd")
bookdown::publish_book("index.Rmd")
setwd("~/best books/GitHub/DSFA")
bookdown::render_book("index.Rmd")
bookdown::publish_book("index.Rmd")
()
publish_book()
bookdown::publish_book("index.Rmd","BEST")
bookdown::publish_book("index.Rmd","BEST")
bookdown::publish_book("index.Rmd","BEST")
bookdown::publish_book("index.Rmd","BEST")
bookdown::publish_book("index.Rmd","BEST")
rsconnect::connectUser
library(bookdown)
bookdown::publish_book()
bookdown::publish_book()
bookdown::render_book()
bookdown::render_book("index.Rmd")
bookdown::publish_book()
bookdown::render_book("index.Rmd")
bookdown::publish_book()
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::publish_book()
bookdown::render_book("index.Rmd")
bookdown::publish_book()
bookdown::publish_book()
bookdown::render_book("index.Rmd")
bookdown::publish_book()
bookdown::render_book("index.Rmd")
bookdown::publish_book()
library(bookdown)
setwd("D:/ABCN/Github/manosaladataopenbook")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("01-intro.Rmd")
bookdown::render_book("01-intro.Rmd")
bookdown::render_book("01-intro.Rmd")
bookdown::render_book("01-intro.Rmd")
bookdown::render_book("02-contribucion.Rmd")
bookdown::render_book("02-contribucion.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("index.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
bookdown::render_book("01-week1.Rmd")
View(municipalidades)
names(municipalidades)
Enconding(municipalidades)
?Encoding
Enconding(names(municipalidades))
Encoding(names(municipalidades))
View(municipalidades)
municipalidades <- readr::read_csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv', fileEncoding = "UTF-8")
municipalidades <- read.csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv', fileEncoding = "UTF-8")
municipalidades <- read.csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv')
?read.csv
municipalidades <- read.csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv', fileEncoding = "UTF-8")
source('D:/ABCN/Github/manos-a-la-data/data/2020/2020-03-04/limpieza.R', encoding = 'UTF-8')
municipalidades <- read.csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv', fileEncoding = "UTF-8")
municipalidades <- read.csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv', fileEncoding = "UTF-8")
municipalidades <- readr::read_csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv')
View(municipalidades)
names(municipalidades)
names(municipalidades)
names(municipalidades)[4,6]
names(municipalidades)[c(4,6)]
names(municipalidades)[c(4,6)]<-c("Certificacion","Atencion de Compromiso Mensual")
write.csv(municipalidades,"municipalidades.csv",row.names = F,fileEncoding = "UTF-8")
municipalidades <- readr::read_csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv')
municipalidades <- readr::read_csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv')
municipalidades <- readr::read_csv('https://raw.githubusercontent.com/BESTDATASCIENCE/manos-a-la-data/master/data/2020/2020-03-04/municipalidades-lima.csv')
